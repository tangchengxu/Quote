// Generated by ProtoGen, Version=2.4.1.555, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Parsing {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class Parsing {
  
    #region Extension registration
    public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    internal static pbd::MessageDescriptor internal__static_Parsing_QuoteReq__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.QuoteReq, global::Parsing.QuoteReq.Builder> internal__static_Parsing_QuoteReq__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Parsing_OtherQuote__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.OtherQuote, global::Parsing.OtherQuote.Builder> internal__static_Parsing_OtherQuote__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Parsing_QuoteInfo__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.QuoteInfo, global::Parsing.QuoteInfo.Builder> internal__static_Parsing_QuoteInfo__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Parsing_BondQuoteInfo__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.BondQuoteInfo, global::Parsing.BondQuoteInfo.Builder> internal__static_Parsing_BondQuoteInfo__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Parsing_RangeBondQuote__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.RangeBondQuote, global::Parsing.RangeBondQuote.Builder> internal__static_Parsing_RangeBondQuote__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Parsing_QuoteRsp__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.QuoteRsp, global::Parsing.QuoteRsp.Builder> internal__static_Parsing_QuoteRsp__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Parsing_SegmentationReq__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.SegmentationReq, global::Parsing.SegmentationReq.Builder> internal__static_Parsing_SegmentationReq__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Parsing_AddWordMapReq__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.AddWordMapReq, global::Parsing.AddWordMapReq.Builder> internal__static_Parsing_AddWordMapReq__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Parsing_AddWordMapRsp__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.AddWordMapRsp, global::Parsing.AddWordMapRsp.Builder> internal__static_Parsing_AddWordMapRsp__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Parsing_Word__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.Word, global::Parsing.Word.Builder> internal__static_Parsing_Word__FieldAccessorTable;
    internal static pbd::MessageDescriptor internal__static_Parsing_SegmentationRsp__Descriptor;
    internal static pb::FieldAccess.FieldAccessorTable<global::Parsing.SegmentationRsp, global::Parsing.SegmentationRsp.Builder> internal__static_Parsing_SegmentationRsp__FieldAccessorTable;
    #endregion
    #region Descriptor
    public static pbd::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbd::FileDescriptor descriptor;
    
    static Parsing() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Cg1QYXJzaW5nLnByb3RvEgdQYXJzaW5nIkUKCFF1b3RlUmVxEg0KBXF1b3Rl", 
            "GAEgAigJEg4KBmZyb21RURgCIAEoCRIMCgR0b1FRGAMgASgJEgwKBGRhdGUY", 
            "BCABKAkiGwoKT3RoZXJRdW90ZRINCgV3b3JkcxgXIAMoCSKLAQoJUXVvdGVJ", 
            "bmZvEhEKCWRpcmVjdGlvbhgBIAIoCRIOCgZhbW91bnQYAiADKAkSDQoFdGVu", 
            "b3IYAyADKAkSDAoEdHlwZRgEIAMoCRILCgN0YWcYBSADKAkSDQoFcHJpY2UY", 
            "BiABKAkSEwoLcHJvYm9iaWxpdHkYByABKAUSDQoFd29yZHMYFyADKAki0QEK", 
            "DUJvbmRRdW90ZUluZm8SEQoJZGlyZWN0aW9uGAEgAigJEg8KB2JvbmRrZXkY", 
            "AiACKAkSDAoEY29kZRgDIAIoCRIMCgRuYW1lGAQgASgJEg4KBnZvbHVtZRgF", 
            "IAEoCRINCgVwcmljZRgGIAEoCRIQCghwcmljZVRhZxgHIAEoCRIMCgR0ZXh0", 
            "GAggASgJEg4KBmxpbmVObxgJIAEoBRINCgVub3RlcxgKIAMoCRITCgtwcm9i", 
            "b2JpbGl0eRgUIAEoBRINCgV3b3JkcxgXIAMoCSLrAQoOUmFuZ2VCb25kUXVv", 
            "dGUSEQoJZGlyZWN0aW9uGAEgAigJEhEKCXRlcm1TdGFydBgCIAEoCRIPCgd0", 
            "ZXJtRW5kGAMgASgJEhMKC3JhdGluZ1N0YXJ0GAQgASgJEhEKCXJhdGluZ0Vu", 
            "ZBgFIAEoCRITCgt2b2x1bWVTdGFydBgGIAEoCRIRCgl2b2x1bWVFbmQYByAB", 
            "KAkSEAoIYm9uZFR5cGUYCCADKAkSEwoLcHJvYm9iaWxpdHkYFCABKAUSDAoE", 
            "dGV4dBgVIAEoCRIOCgZsaW5lTm8YFiABKAUSDQoFd29yZHMYFyADKAki7QEK", 
            "CFF1b3RlUnNwEicKC21tUXVvdGVMaXN0GAEgAygLMhIuUGFyc2luZy5RdW90", 
            "ZUluZm8SLQoNYm9uZFF1b3RlTGlzdBgCIAMoCzIWLlBhcnNpbmcuQm9uZFF1", 
            "b3RlSW5mbxIvCg5yYW5nZVF1b3RlTGlzdBgDIAMoCzIXLlBhcnNpbmcuUmFu", 
            "Z2VCb25kUXVvdGUSJwoKb3RoZXJRdW90ZRgEIAEoCzITLlBhcnNpbmcuT3Ro", 
            "ZXJRdW90ZRIOCgZ0cmFkZXIYCyABKAkSDwoHY29tcGFueRgMIAEoCRIOCgZJ", 
            "c0RlYWwYBSABKAgiHwoPU2VnbWVudGF0aW9uUmVxEgwKBHRleHQYASACKAki", 
            "UAoNQWRkV29yZE1hcFJlcRIRCglHcm91cFR5cGUYASACKAkSDQoFSW5wdXQY", 
            "AiACKAkSDgoGT3V0cHV0GAMgAigJEg0KBVZhbHVlGAQgASgJIhwKDUFkZFdv", 
            "cmRNYXBSc3ASCwoDcmV0GAEgAigJIiIKBFdvcmQSDAoEd29yZBgBIAIoCRIM", 
            "CgR0eXBlGAIgAigJIi4KD1NlZ21lbnRhdGlvblJzcBIbCgRpbmZvGAEgAygL", 
          "Mg0uUGFyc2luZy5Xb3JkQhcKDGNvbS5wcm90b2J1ZkIHUGFyc2luZw=="));
      pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
        descriptor = root;
        internal__static_Parsing_QuoteReq__Descriptor = Descriptor.MessageTypes[0];
        internal__static_Parsing_QuoteReq__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.QuoteReq, global::Parsing.QuoteReq.Builder>(internal__static_Parsing_QuoteReq__Descriptor,
                new string[] { "Quote", "FromQQ", "ToQQ", "Date", });
        internal__static_Parsing_OtherQuote__Descriptor = Descriptor.MessageTypes[1];
        internal__static_Parsing_OtherQuote__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.OtherQuote, global::Parsing.OtherQuote.Builder>(internal__static_Parsing_OtherQuote__Descriptor,
                new string[] { "Words", });
        internal__static_Parsing_QuoteInfo__Descriptor = Descriptor.MessageTypes[2];
        internal__static_Parsing_QuoteInfo__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.QuoteInfo, global::Parsing.QuoteInfo.Builder>(internal__static_Parsing_QuoteInfo__Descriptor,
                new string[] { "Direction", "Amount", "Tenor", "Type", "Tag", "Price", "Probobility", "Words", });
        internal__static_Parsing_BondQuoteInfo__Descriptor = Descriptor.MessageTypes[3];
        internal__static_Parsing_BondQuoteInfo__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.BondQuoteInfo, global::Parsing.BondQuoteInfo.Builder>(internal__static_Parsing_BondQuoteInfo__Descriptor,
                new string[] { "Direction", "Bondkey", "Code", "Name", "Volume", "Price", "PriceTag", "Text", "LineNo", "Notes", "Probobility", "Words", });
        internal__static_Parsing_RangeBondQuote__Descriptor = Descriptor.MessageTypes[4];
        internal__static_Parsing_RangeBondQuote__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.RangeBondQuote, global::Parsing.RangeBondQuote.Builder>(internal__static_Parsing_RangeBondQuote__Descriptor,
                new string[] { "Direction", "TermStart", "TermEnd", "RatingStart", "RatingEnd", "VolumeStart", "VolumeEnd", "BondType", "Probobility", "Text", "LineNo", "Words", });
        internal__static_Parsing_QuoteRsp__Descriptor = Descriptor.MessageTypes[5];
        internal__static_Parsing_QuoteRsp__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.QuoteRsp, global::Parsing.QuoteRsp.Builder>(internal__static_Parsing_QuoteRsp__Descriptor,
                new string[] { "MmQuoteList", "BondQuoteList", "RangeQuoteList", "OtherQuote", "Trader", "Company", "IsDeal", });
        internal__static_Parsing_SegmentationReq__Descriptor = Descriptor.MessageTypes[6];
        internal__static_Parsing_SegmentationReq__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.SegmentationReq, global::Parsing.SegmentationReq.Builder>(internal__static_Parsing_SegmentationReq__Descriptor,
                new string[] { "Text", });
        internal__static_Parsing_AddWordMapReq__Descriptor = Descriptor.MessageTypes[7];
        internal__static_Parsing_AddWordMapReq__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.AddWordMapReq, global::Parsing.AddWordMapReq.Builder>(internal__static_Parsing_AddWordMapReq__Descriptor,
                new string[] { "GroupType", "Input", "Output", "Value", });
        internal__static_Parsing_AddWordMapRsp__Descriptor = Descriptor.MessageTypes[8];
        internal__static_Parsing_AddWordMapRsp__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.AddWordMapRsp, global::Parsing.AddWordMapRsp.Builder>(internal__static_Parsing_AddWordMapRsp__Descriptor,
                new string[] { "Ret", });
        internal__static_Parsing_Word__Descriptor = Descriptor.MessageTypes[9];
        internal__static_Parsing_Word__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.Word, global::Parsing.Word.Builder>(internal__static_Parsing_Word__Descriptor,
                new string[] { "Word_", "Type", });
        internal__static_Parsing_SegmentationRsp__Descriptor = Descriptor.MessageTypes[10];
        internal__static_Parsing_SegmentationRsp__FieldAccessorTable = 
            new pb::FieldAccess.FieldAccessorTable<global::Parsing.SegmentationRsp, global::Parsing.SegmentationRsp.Builder>(internal__static_Parsing_SegmentationRsp__Descriptor,
                new string[] { "Info", });
        return null;
      };
      pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
          new pbd::FileDescriptor[] {
          }, assigner);
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class QuoteReq : pb::GeneratedMessage<QuoteReq, QuoteReq.Builder> {
    private QuoteReq() { }
    private static readonly QuoteReq defaultInstance = new QuoteReq().MakeReadOnly();
    private static readonly string[] _quoteReqFieldNames = new string[] { "date", "fromQQ", "quote", "toQQ" };
    private static readonly uint[] _quoteReqFieldTags = new uint[] { 34, 18, 10, 26 };
    public static QuoteReq DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override QuoteReq DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override QuoteReq ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_QuoteReq__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<QuoteReq, QuoteReq.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_QuoteReq__FieldAccessorTable; }
    }
    
    public const int QuoteFieldNumber = 1;
    private bool hasQuote;
    private string quote_ = "";
    public bool HasQuote {
      get { return hasQuote; }
    }
    public string Quote {
      get { return quote_; }
    }
    
    public const int FromQQFieldNumber = 2;
    private bool hasFromQQ;
    private string fromQQ_ = "";
    public bool HasFromQQ {
      get { return hasFromQQ; }
    }
    public string FromQQ {
      get { return fromQQ_; }
    }
    
    public const int ToQQFieldNumber = 3;
    private bool hasToQQ;
    private string toQQ_ = "";
    public bool HasToQQ {
      get { return hasToQQ; }
    }
    public string ToQQ {
      get { return toQQ_; }
    }
    
    public const int DateFieldNumber = 4;
    private bool hasDate;
    private string date_ = "";
    public bool HasDate {
      get { return hasDate; }
    }
    public string Date {
      get { return date_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasQuote) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _quoteReqFieldNames;
      if (hasQuote) {
        output.WriteString(1, field_names[2], Quote);
      }
      if (hasFromQQ) {
        output.WriteString(2, field_names[1], FromQQ);
      }
      if (hasToQQ) {
        output.WriteString(3, field_names[3], ToQQ);
      }
      if (hasDate) {
        output.WriteString(4, field_names[0], Date);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasQuote) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Quote);
      }
      if (hasFromQQ) {
        size += pb::CodedOutputStream.ComputeStringSize(2, FromQQ);
      }
      if (hasToQQ) {
        size += pb::CodedOutputStream.ComputeStringSize(3, ToQQ);
      }
      if (hasDate) {
        size += pb::CodedOutputStream.ComputeStringSize(4, Date);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static QuoteReq ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static QuoteReq ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static QuoteReq ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static QuoteReq ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static QuoteReq ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static QuoteReq ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static QuoteReq ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static QuoteReq ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static QuoteReq ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static QuoteReq ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private QuoteReq MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(QuoteReq prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<QuoteReq, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(QuoteReq cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private QuoteReq result;
      
      private QuoteReq PrepareBuilder() {
        if (resultIsReadOnly) {
          QuoteReq original = result;
          result = new QuoteReq();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override QuoteReq MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.QuoteReq.Descriptor; }
      }
      
      public override QuoteReq DefaultInstanceForType {
        get { return global::Parsing.QuoteReq.DefaultInstance; }
      }
      
      public override QuoteReq BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is QuoteReq) {
          return MergeFrom((QuoteReq) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(QuoteReq other) {
        if (other == global::Parsing.QuoteReq.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasQuote) {
          Quote = other.Quote;
        }
        if (other.HasFromQQ) {
          FromQQ = other.FromQQ;
        }
        if (other.HasToQQ) {
          ToQQ = other.ToQQ;
        }
        if (other.HasDate) {
          Date = other.Date;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_quoteReqFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _quoteReqFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasQuote = input.ReadString(ref result.quote_);
              break;
            }
            case 18: {
              result.hasFromQQ = input.ReadString(ref result.fromQQ_);
              break;
            }
            case 26: {
              result.hasToQQ = input.ReadString(ref result.toQQ_);
              break;
            }
            case 34: {
              result.hasDate = input.ReadString(ref result.date_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasQuote {
        get { return result.hasQuote; }
      }
      public string Quote {
        get { return result.Quote; }
        set { SetQuote(value); }
      }
      public Builder SetQuote(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasQuote = true;
        result.quote_ = value;
        return this;
      }
      public Builder ClearQuote() {
        PrepareBuilder();
        result.hasQuote = false;
        result.quote_ = "";
        return this;
      }
      
      public bool HasFromQQ {
        get { return result.hasFromQQ; }
      }
      public string FromQQ {
        get { return result.FromQQ; }
        set { SetFromQQ(value); }
      }
      public Builder SetFromQQ(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasFromQQ = true;
        result.fromQQ_ = value;
        return this;
      }
      public Builder ClearFromQQ() {
        PrepareBuilder();
        result.hasFromQQ = false;
        result.fromQQ_ = "";
        return this;
      }
      
      public bool HasToQQ {
        get { return result.hasToQQ; }
      }
      public string ToQQ {
        get { return result.ToQQ; }
        set { SetToQQ(value); }
      }
      public Builder SetToQQ(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasToQQ = true;
        result.toQQ_ = value;
        return this;
      }
      public Builder ClearToQQ() {
        PrepareBuilder();
        result.hasToQQ = false;
        result.toQQ_ = "";
        return this;
      }
      
      public bool HasDate {
        get { return result.hasDate; }
      }
      public string Date {
        get { return result.Date; }
        set { SetDate(value); }
      }
      public Builder SetDate(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDate = true;
        result.date_ = value;
        return this;
      }
      public Builder ClearDate() {
        PrepareBuilder();
        result.hasDate = false;
        result.date_ = "";
        return this;
      }
    }
    static QuoteReq() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class OtherQuote : pb::GeneratedMessage<OtherQuote, OtherQuote.Builder> {
    private OtherQuote() { }
    private static readonly OtherQuote defaultInstance = new OtherQuote().MakeReadOnly();
    private static readonly string[] _otherQuoteFieldNames = new string[] { "words" };
    private static readonly uint[] _otherQuoteFieldTags = new uint[] { 186 };
    public static OtherQuote DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override OtherQuote DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override OtherQuote ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_OtherQuote__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<OtherQuote, OtherQuote.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_OtherQuote__FieldAccessorTable; }
    }
    
    public const int WordsFieldNumber = 23;
    private pbc::PopsicleList<string> words_ = new pbc::PopsicleList<string>();
    public scg::IList<string> WordsList {
      get { return pbc::Lists.AsReadOnly(words_); }
    }
    public int WordsCount {
      get { return words_.Count; }
    }
    public string GetWords(int index) {
      return words_[index];
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _otherQuoteFieldNames;
      if (words_.Count > 0) {
        output.WriteStringArray(23, field_names[0], words_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      {
        int dataSize = 0;
        foreach (string element in WordsList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 2 * words_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static OtherQuote ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OtherQuote ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OtherQuote ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static OtherQuote ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static OtherQuote ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OtherQuote ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static OtherQuote ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static OtherQuote ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static OtherQuote ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static OtherQuote ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private OtherQuote MakeReadOnly() {
      words_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(OtherQuote prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<OtherQuote, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(OtherQuote cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private OtherQuote result;
      
      private OtherQuote PrepareBuilder() {
        if (resultIsReadOnly) {
          OtherQuote original = result;
          result = new OtherQuote();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override OtherQuote MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.OtherQuote.Descriptor; }
      }
      
      public override OtherQuote DefaultInstanceForType {
        get { return global::Parsing.OtherQuote.DefaultInstance; }
      }
      
      public override OtherQuote BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is OtherQuote) {
          return MergeFrom((OtherQuote) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(OtherQuote other) {
        if (other == global::Parsing.OtherQuote.DefaultInstance) return this;
        PrepareBuilder();
        if (other.words_.Count != 0) {
          result.words_.Add(other.words_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_otherQuoteFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _otherQuoteFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 186: {
              input.ReadStringArray(tag, field_name, result.words_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<string> WordsList {
        get { return PrepareBuilder().words_; }
      }
      public int WordsCount {
        get { return result.WordsCount; }
      }
      public string GetWords(int index) {
        return result.GetWords(index);
      }
      public Builder SetWords(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.words_[index] = value;
        return this;
      }
      public Builder AddWords(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.words_.Add(value);
        return this;
      }
      public Builder AddRangeWords(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.words_.Add(values);
        return this;
      }
      public Builder ClearWords() {
        PrepareBuilder();
        result.words_.Clear();
        return this;
      }
    }
    static OtherQuote() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class QuoteInfo : pb::GeneratedMessage<QuoteInfo, QuoteInfo.Builder> {
    private QuoteInfo() { }
    private static readonly QuoteInfo defaultInstance = new QuoteInfo().MakeReadOnly();
    private static readonly string[] _quoteInfoFieldNames = new string[] { "amount", "direction", "price", "probobility", "tag", "tenor", "type", "words" };
    private static readonly uint[] _quoteInfoFieldTags = new uint[] { 18, 10, 50, 56, 42, 26, 34, 186 };
    public static QuoteInfo DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override QuoteInfo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override QuoteInfo ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_QuoteInfo__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<QuoteInfo, QuoteInfo.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_QuoteInfo__FieldAccessorTable; }
    }
    
    public const int DirectionFieldNumber = 1;
    private bool hasDirection;
    private string direction_ = "";
    public bool HasDirection {
      get { return hasDirection; }
    }
    public string Direction {
      get { return direction_; }
    }
    
    public const int AmountFieldNumber = 2;
    private pbc::PopsicleList<string> amount_ = new pbc::PopsicleList<string>();
    public scg::IList<string> AmountList {
      get { return pbc::Lists.AsReadOnly(amount_); }
    }
    public int AmountCount {
      get { return amount_.Count; }
    }
    public string GetAmount(int index) {
      return amount_[index];
    }
    
    public const int TenorFieldNumber = 3;
    private pbc::PopsicleList<string> tenor_ = new pbc::PopsicleList<string>();
    public scg::IList<string> TenorList {
      get { return pbc::Lists.AsReadOnly(tenor_); }
    }
    public int TenorCount {
      get { return tenor_.Count; }
    }
    public string GetTenor(int index) {
      return tenor_[index];
    }
    
    public const int TypeFieldNumber = 4;
    private pbc::PopsicleList<string> type_ = new pbc::PopsicleList<string>();
    public scg::IList<string> TypeList {
      get { return pbc::Lists.AsReadOnly(type_); }
    }
    public int TypeCount {
      get { return type_.Count; }
    }
    public string GetType(int index) {
      return type_[index];
    }
    
    public const int TagFieldNumber = 5;
    private pbc::PopsicleList<string> tag_ = new pbc::PopsicleList<string>();
    public scg::IList<string> TagList {
      get { return pbc::Lists.AsReadOnly(tag_); }
    }
    public int TagCount {
      get { return tag_.Count; }
    }
    public string GetTag(int index) {
      return tag_[index];
    }
    
    public const int PriceFieldNumber = 6;
    private bool hasPrice;
    private string price_ = "";
    public bool HasPrice {
      get { return hasPrice; }
    }
    public string Price {
      get { return price_; }
    }
    
    public const int ProbobilityFieldNumber = 7;
    private bool hasProbobility;
    private int probobility_;
    public bool HasProbobility {
      get { return hasProbobility; }
    }
    public int Probobility {
      get { return probobility_; }
    }
    
    public const int WordsFieldNumber = 23;
    private pbc::PopsicleList<string> words_ = new pbc::PopsicleList<string>();
    public scg::IList<string> WordsList {
      get { return pbc::Lists.AsReadOnly(words_); }
    }
    public int WordsCount {
      get { return words_.Count; }
    }
    public string GetWords(int index) {
      return words_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasDirection) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _quoteInfoFieldNames;
      if (hasDirection) {
        output.WriteString(1, field_names[1], Direction);
      }
      if (amount_.Count > 0) {
        output.WriteStringArray(2, field_names[0], amount_);
      }
      if (tenor_.Count > 0) {
        output.WriteStringArray(3, field_names[5], tenor_);
      }
      if (type_.Count > 0) {
        output.WriteStringArray(4, field_names[6], type_);
      }
      if (tag_.Count > 0) {
        output.WriteStringArray(5, field_names[4], tag_);
      }
      if (hasPrice) {
        output.WriteString(6, field_names[2], Price);
      }
      if (hasProbobility) {
        output.WriteInt32(7, field_names[3], Probobility);
      }
      if (words_.Count > 0) {
        output.WriteStringArray(23, field_names[7], words_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasDirection) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Direction);
      }
      {
        int dataSize = 0;
        foreach (string element in AmountList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * amount_.Count;
      }
      {
        int dataSize = 0;
        foreach (string element in TenorList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * tenor_.Count;
      }
      {
        int dataSize = 0;
        foreach (string element in TypeList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * type_.Count;
      }
      {
        int dataSize = 0;
        foreach (string element in TagList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * tag_.Count;
      }
      if (hasPrice) {
        size += pb::CodedOutputStream.ComputeStringSize(6, Price);
      }
      if (hasProbobility) {
        size += pb::CodedOutputStream.ComputeInt32Size(7, Probobility);
      }
      {
        int dataSize = 0;
        foreach (string element in WordsList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 2 * words_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static QuoteInfo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static QuoteInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static QuoteInfo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static QuoteInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static QuoteInfo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static QuoteInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static QuoteInfo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static QuoteInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static QuoteInfo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static QuoteInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private QuoteInfo MakeReadOnly() {
      amount_.MakeReadOnly();
      tenor_.MakeReadOnly();
      type_.MakeReadOnly();
      tag_.MakeReadOnly();
      words_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(QuoteInfo prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<QuoteInfo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(QuoteInfo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private QuoteInfo result;
      
      private QuoteInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          QuoteInfo original = result;
          result = new QuoteInfo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override QuoteInfo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.QuoteInfo.Descriptor; }
      }
      
      public override QuoteInfo DefaultInstanceForType {
        get { return global::Parsing.QuoteInfo.DefaultInstance; }
      }
      
      public override QuoteInfo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is QuoteInfo) {
          return MergeFrom((QuoteInfo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(QuoteInfo other) {
        if (other == global::Parsing.QuoteInfo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasDirection) {
          Direction = other.Direction;
        }
        if (other.amount_.Count != 0) {
          result.amount_.Add(other.amount_);
        }
        if (other.tenor_.Count != 0) {
          result.tenor_.Add(other.tenor_);
        }
        if (other.type_.Count != 0) {
          result.type_.Add(other.type_);
        }
        if (other.tag_.Count != 0) {
          result.tag_.Add(other.tag_);
        }
        if (other.HasPrice) {
          Price = other.Price;
        }
        if (other.HasProbobility) {
          Probobility = other.Probobility;
        }
        if (other.words_.Count != 0) {
          result.words_.Add(other.words_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_quoteInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _quoteInfoFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasDirection = input.ReadString(ref result.direction_);
              break;
            }
            case 18: {
              input.ReadStringArray(tag, field_name, result.amount_);
              break;
            }
            case 26: {
              input.ReadStringArray(tag, field_name, result.tenor_);
              break;
            }
            case 34: {
              input.ReadStringArray(tag, field_name, result.type_);
              break;
            }
            case 42: {
              input.ReadStringArray(tag, field_name, result.tag_);
              break;
            }
            case 50: {
              result.hasPrice = input.ReadString(ref result.price_);
              break;
            }
            case 56: {
              result.hasProbobility = input.ReadInt32(ref result.probobility_);
              break;
            }
            case 186: {
              input.ReadStringArray(tag, field_name, result.words_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasDirection {
        get { return result.hasDirection; }
      }
      public string Direction {
        get { return result.Direction; }
        set { SetDirection(value); }
      }
      public Builder SetDirection(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDirection = true;
        result.direction_ = value;
        return this;
      }
      public Builder ClearDirection() {
        PrepareBuilder();
        result.hasDirection = false;
        result.direction_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<string> AmountList {
        get { return PrepareBuilder().amount_; }
      }
      public int AmountCount {
        get { return result.AmountCount; }
      }
      public string GetAmount(int index) {
        return result.GetAmount(index);
      }
      public Builder SetAmount(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.amount_[index] = value;
        return this;
      }
      public Builder AddAmount(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.amount_.Add(value);
        return this;
      }
      public Builder AddRangeAmount(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.amount_.Add(values);
        return this;
      }
      public Builder ClearAmount() {
        PrepareBuilder();
        result.amount_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<string> TenorList {
        get { return PrepareBuilder().tenor_; }
      }
      public int TenorCount {
        get { return result.TenorCount; }
      }
      public string GetTenor(int index) {
        return result.GetTenor(index);
      }
      public Builder SetTenor(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.tenor_[index] = value;
        return this;
      }
      public Builder AddTenor(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.tenor_.Add(value);
        return this;
      }
      public Builder AddRangeTenor(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.tenor_.Add(values);
        return this;
      }
      public Builder ClearTenor() {
        PrepareBuilder();
        result.tenor_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<string> TypeList {
        get { return PrepareBuilder().type_; }
      }
      public int TypeCount {
        get { return result.TypeCount; }
      }
      public string GetType(int index) {
        return result.GetType(index);
      }
      public Builder SetType(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.type_[index] = value;
        return this;
      }
      public Builder AddType(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.type_.Add(value);
        return this;
      }
      public Builder AddRangeType(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.type_.Add(values);
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.type_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<string> TagList {
        get { return PrepareBuilder().tag_; }
      }
      public int TagCount {
        get { return result.TagCount; }
      }
      public string GetTag(int index) {
        return result.GetTag(index);
      }
      public Builder SetTag(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.tag_[index] = value;
        return this;
      }
      public Builder AddTag(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.tag_.Add(value);
        return this;
      }
      public Builder AddRangeTag(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.tag_.Add(values);
        return this;
      }
      public Builder ClearTag() {
        PrepareBuilder();
        result.tag_.Clear();
        return this;
      }
      
      public bool HasPrice {
        get { return result.hasPrice; }
      }
      public string Price {
        get { return result.Price; }
        set { SetPrice(value); }
      }
      public Builder SetPrice(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPrice = true;
        result.price_ = value;
        return this;
      }
      public Builder ClearPrice() {
        PrepareBuilder();
        result.hasPrice = false;
        result.price_ = "";
        return this;
      }
      
      public bool HasProbobility {
        get { return result.hasProbobility; }
      }
      public int Probobility {
        get { return result.Probobility; }
        set { SetProbobility(value); }
      }
      public Builder SetProbobility(int value) {
        PrepareBuilder();
        result.hasProbobility = true;
        result.probobility_ = value;
        return this;
      }
      public Builder ClearProbobility() {
        PrepareBuilder();
        result.hasProbobility = false;
        result.probobility_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<string> WordsList {
        get { return PrepareBuilder().words_; }
      }
      public int WordsCount {
        get { return result.WordsCount; }
      }
      public string GetWords(int index) {
        return result.GetWords(index);
      }
      public Builder SetWords(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.words_[index] = value;
        return this;
      }
      public Builder AddWords(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.words_.Add(value);
        return this;
      }
      public Builder AddRangeWords(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.words_.Add(values);
        return this;
      }
      public Builder ClearWords() {
        PrepareBuilder();
        result.words_.Clear();
        return this;
      }
    }
    static QuoteInfo() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class BondQuoteInfo : pb::GeneratedMessage<BondQuoteInfo, BondQuoteInfo.Builder> {
    private BondQuoteInfo() { }
    private static readonly BondQuoteInfo defaultInstance = new BondQuoteInfo().MakeReadOnly();
    private static readonly string[] _bondQuoteInfoFieldNames = new string[] { "bondkey", "code", "direction", "lineNo", "name", "notes", "price", "priceTag", "probobility", "text", "volume", "words" };
    private static readonly uint[] _bondQuoteInfoFieldTags = new uint[] { 18, 26, 10, 72, 34, 82, 50, 58, 160, 66, 42, 186 };
    public static BondQuoteInfo DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override BondQuoteInfo DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override BondQuoteInfo ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_BondQuoteInfo__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<BondQuoteInfo, BondQuoteInfo.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_BondQuoteInfo__FieldAccessorTable; }
    }
    
    public const int DirectionFieldNumber = 1;
    private bool hasDirection;
    private string direction_ = "";
    public bool HasDirection {
      get { return hasDirection; }
    }
    public string Direction {
      get { return direction_; }
    }
    
    public const int BondkeyFieldNumber = 2;
    private bool hasBondkey;
    private string bondkey_ = "";
    public bool HasBondkey {
      get { return hasBondkey; }
    }
    public string Bondkey {
      get { return bondkey_; }
    }
    
    public const int CodeFieldNumber = 3;
    private bool hasCode;
    private string code_ = "";
    public bool HasCode {
      get { return hasCode; }
    }
    public string Code {
      get { return code_; }
    }
    
    public const int NameFieldNumber = 4;
    private bool hasName;
    private string name_ = "";
    public bool HasName {
      get { return hasName; }
    }
    public string Name {
      get { return name_; }
    }
    
    public const int VolumeFieldNumber = 5;
    private bool hasVolume;
    private string volume_ = "";
    public bool HasVolume {
      get { return hasVolume; }
    }
    public string Volume {
      get { return volume_; }
    }
    
    public const int PriceFieldNumber = 6;
    private bool hasPrice;
    private string price_ = "";
    public bool HasPrice {
      get { return hasPrice; }
    }
    public string Price {
      get { return price_; }
    }
    
    public const int PriceTagFieldNumber = 7;
    private bool hasPriceTag;
    private string priceTag_ = "";
    public bool HasPriceTag {
      get { return hasPriceTag; }
    }
    public string PriceTag {
      get { return priceTag_; }
    }
    
    public const int TextFieldNumber = 8;
    private bool hasText;
    private string text_ = "";
    public bool HasText {
      get { return hasText; }
    }
    public string Text {
      get { return text_; }
    }
    
    public const int LineNoFieldNumber = 9;
    private bool hasLineNo;
    private int lineNo_;
    public bool HasLineNo {
      get { return hasLineNo; }
    }
    public int LineNo {
      get { return lineNo_; }
    }
    
    public const int NotesFieldNumber = 10;
    private pbc::PopsicleList<string> notes_ = new pbc::PopsicleList<string>();
    public scg::IList<string> NotesList {
      get { return pbc::Lists.AsReadOnly(notes_); }
    }
    public int NotesCount {
      get { return notes_.Count; }
    }
    public string GetNotes(int index) {
      return notes_[index];
    }
    
    public const int ProbobilityFieldNumber = 20;
    private bool hasProbobility;
    private int probobility_;
    public bool HasProbobility {
      get { return hasProbobility; }
    }
    public int Probobility {
      get { return probobility_; }
    }
    
    public const int WordsFieldNumber = 23;
    private pbc::PopsicleList<string> words_ = new pbc::PopsicleList<string>();
    public scg::IList<string> WordsList {
      get { return pbc::Lists.AsReadOnly(words_); }
    }
    public int WordsCount {
      get { return words_.Count; }
    }
    public string GetWords(int index) {
      return words_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasDirection) return false;
        if (!hasBondkey) return false;
        if (!hasCode) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _bondQuoteInfoFieldNames;
      if (hasDirection) {
        output.WriteString(1, field_names[2], Direction);
      }
      if (hasBondkey) {
        output.WriteString(2, field_names[0], Bondkey);
      }
      if (hasCode) {
        output.WriteString(3, field_names[1], Code);
      }
      if (hasName) {
        output.WriteString(4, field_names[4], Name);
      }
      if (hasVolume) {
        output.WriteString(5, field_names[10], Volume);
      }
      if (hasPrice) {
        output.WriteString(6, field_names[6], Price);
      }
      if (hasPriceTag) {
        output.WriteString(7, field_names[7], PriceTag);
      }
      if (hasText) {
        output.WriteString(8, field_names[9], Text);
      }
      if (hasLineNo) {
        output.WriteInt32(9, field_names[3], LineNo);
      }
      if (notes_.Count > 0) {
        output.WriteStringArray(10, field_names[5], notes_);
      }
      if (hasProbobility) {
        output.WriteInt32(20, field_names[8], Probobility);
      }
      if (words_.Count > 0) {
        output.WriteStringArray(23, field_names[11], words_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasDirection) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Direction);
      }
      if (hasBondkey) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Bondkey);
      }
      if (hasCode) {
        size += pb::CodedOutputStream.ComputeStringSize(3, Code);
      }
      if (hasName) {
        size += pb::CodedOutputStream.ComputeStringSize(4, Name);
      }
      if (hasVolume) {
        size += pb::CodedOutputStream.ComputeStringSize(5, Volume);
      }
      if (hasPrice) {
        size += pb::CodedOutputStream.ComputeStringSize(6, Price);
      }
      if (hasPriceTag) {
        size += pb::CodedOutputStream.ComputeStringSize(7, PriceTag);
      }
      if (hasText) {
        size += pb::CodedOutputStream.ComputeStringSize(8, Text);
      }
      if (hasLineNo) {
        size += pb::CodedOutputStream.ComputeInt32Size(9, LineNo);
      }
      {
        int dataSize = 0;
        foreach (string element in NotesList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * notes_.Count;
      }
      if (hasProbobility) {
        size += pb::CodedOutputStream.ComputeInt32Size(20, Probobility);
      }
      {
        int dataSize = 0;
        foreach (string element in WordsList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 2 * words_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static BondQuoteInfo ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BondQuoteInfo ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BondQuoteInfo ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static BondQuoteInfo ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static BondQuoteInfo ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BondQuoteInfo ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static BondQuoteInfo ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static BondQuoteInfo ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static BondQuoteInfo ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static BondQuoteInfo ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private BondQuoteInfo MakeReadOnly() {
      notes_.MakeReadOnly();
      words_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(BondQuoteInfo prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<BondQuoteInfo, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(BondQuoteInfo cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private BondQuoteInfo result;
      
      private BondQuoteInfo PrepareBuilder() {
        if (resultIsReadOnly) {
          BondQuoteInfo original = result;
          result = new BondQuoteInfo();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override BondQuoteInfo MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.BondQuoteInfo.Descriptor; }
      }
      
      public override BondQuoteInfo DefaultInstanceForType {
        get { return global::Parsing.BondQuoteInfo.DefaultInstance; }
      }
      
      public override BondQuoteInfo BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is BondQuoteInfo) {
          return MergeFrom((BondQuoteInfo) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(BondQuoteInfo other) {
        if (other == global::Parsing.BondQuoteInfo.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasDirection) {
          Direction = other.Direction;
        }
        if (other.HasBondkey) {
          Bondkey = other.Bondkey;
        }
        if (other.HasCode) {
          Code = other.Code;
        }
        if (other.HasName) {
          Name = other.Name;
        }
        if (other.HasVolume) {
          Volume = other.Volume;
        }
        if (other.HasPrice) {
          Price = other.Price;
        }
        if (other.HasPriceTag) {
          PriceTag = other.PriceTag;
        }
        if (other.HasText) {
          Text = other.Text;
        }
        if (other.HasLineNo) {
          LineNo = other.LineNo;
        }
        if (other.notes_.Count != 0) {
          result.notes_.Add(other.notes_);
        }
        if (other.HasProbobility) {
          Probobility = other.Probobility;
        }
        if (other.words_.Count != 0) {
          result.words_.Add(other.words_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_bondQuoteInfoFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _bondQuoteInfoFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasDirection = input.ReadString(ref result.direction_);
              break;
            }
            case 18: {
              result.hasBondkey = input.ReadString(ref result.bondkey_);
              break;
            }
            case 26: {
              result.hasCode = input.ReadString(ref result.code_);
              break;
            }
            case 34: {
              result.hasName = input.ReadString(ref result.name_);
              break;
            }
            case 42: {
              result.hasVolume = input.ReadString(ref result.volume_);
              break;
            }
            case 50: {
              result.hasPrice = input.ReadString(ref result.price_);
              break;
            }
            case 58: {
              result.hasPriceTag = input.ReadString(ref result.priceTag_);
              break;
            }
            case 66: {
              result.hasText = input.ReadString(ref result.text_);
              break;
            }
            case 72: {
              result.hasLineNo = input.ReadInt32(ref result.lineNo_);
              break;
            }
            case 82: {
              input.ReadStringArray(tag, field_name, result.notes_);
              break;
            }
            case 160: {
              result.hasProbobility = input.ReadInt32(ref result.probobility_);
              break;
            }
            case 186: {
              input.ReadStringArray(tag, field_name, result.words_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasDirection {
        get { return result.hasDirection; }
      }
      public string Direction {
        get { return result.Direction; }
        set { SetDirection(value); }
      }
      public Builder SetDirection(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDirection = true;
        result.direction_ = value;
        return this;
      }
      public Builder ClearDirection() {
        PrepareBuilder();
        result.hasDirection = false;
        result.direction_ = "";
        return this;
      }
      
      public bool HasBondkey {
        get { return result.hasBondkey; }
      }
      public string Bondkey {
        get { return result.Bondkey; }
        set { SetBondkey(value); }
      }
      public Builder SetBondkey(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBondkey = true;
        result.bondkey_ = value;
        return this;
      }
      public Builder ClearBondkey() {
        PrepareBuilder();
        result.hasBondkey = false;
        result.bondkey_ = "";
        return this;
      }
      
      public bool HasCode {
        get { return result.hasCode; }
      }
      public string Code {
        get { return result.Code; }
        set { SetCode(value); }
      }
      public Builder SetCode(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCode = true;
        result.code_ = value;
        return this;
      }
      public Builder ClearCode() {
        PrepareBuilder();
        result.hasCode = false;
        result.code_ = "";
        return this;
      }
      
      public bool HasName {
        get { return result.hasName; }
      }
      public string Name {
        get { return result.Name; }
        set { SetName(value); }
      }
      public Builder SetName(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasName = true;
        result.name_ = value;
        return this;
      }
      public Builder ClearName() {
        PrepareBuilder();
        result.hasName = false;
        result.name_ = "";
        return this;
      }
      
      public bool HasVolume {
        get { return result.hasVolume; }
      }
      public string Volume {
        get { return result.Volume; }
        set { SetVolume(value); }
      }
      public Builder SetVolume(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasVolume = true;
        result.volume_ = value;
        return this;
      }
      public Builder ClearVolume() {
        PrepareBuilder();
        result.hasVolume = false;
        result.volume_ = "";
        return this;
      }
      
      public bool HasPrice {
        get { return result.hasPrice; }
      }
      public string Price {
        get { return result.Price; }
        set { SetPrice(value); }
      }
      public Builder SetPrice(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPrice = true;
        result.price_ = value;
        return this;
      }
      public Builder ClearPrice() {
        PrepareBuilder();
        result.hasPrice = false;
        result.price_ = "";
        return this;
      }
      
      public bool HasPriceTag {
        get { return result.hasPriceTag; }
      }
      public string PriceTag {
        get { return result.PriceTag; }
        set { SetPriceTag(value); }
      }
      public Builder SetPriceTag(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPriceTag = true;
        result.priceTag_ = value;
        return this;
      }
      public Builder ClearPriceTag() {
        PrepareBuilder();
        result.hasPriceTag = false;
        result.priceTag_ = "";
        return this;
      }
      
      public bool HasText {
        get { return result.hasText; }
      }
      public string Text {
        get { return result.Text; }
        set { SetText(value); }
      }
      public Builder SetText(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasText = true;
        result.text_ = value;
        return this;
      }
      public Builder ClearText() {
        PrepareBuilder();
        result.hasText = false;
        result.text_ = "";
        return this;
      }
      
      public bool HasLineNo {
        get { return result.hasLineNo; }
      }
      public int LineNo {
        get { return result.LineNo; }
        set { SetLineNo(value); }
      }
      public Builder SetLineNo(int value) {
        PrepareBuilder();
        result.hasLineNo = true;
        result.lineNo_ = value;
        return this;
      }
      public Builder ClearLineNo() {
        PrepareBuilder();
        result.hasLineNo = false;
        result.lineNo_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<string> NotesList {
        get { return PrepareBuilder().notes_; }
      }
      public int NotesCount {
        get { return result.NotesCount; }
      }
      public string GetNotes(int index) {
        return result.GetNotes(index);
      }
      public Builder SetNotes(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.notes_[index] = value;
        return this;
      }
      public Builder AddNotes(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.notes_.Add(value);
        return this;
      }
      public Builder AddRangeNotes(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.notes_.Add(values);
        return this;
      }
      public Builder ClearNotes() {
        PrepareBuilder();
        result.notes_.Clear();
        return this;
      }
      
      public bool HasProbobility {
        get { return result.hasProbobility; }
      }
      public int Probobility {
        get { return result.Probobility; }
        set { SetProbobility(value); }
      }
      public Builder SetProbobility(int value) {
        PrepareBuilder();
        result.hasProbobility = true;
        result.probobility_ = value;
        return this;
      }
      public Builder ClearProbobility() {
        PrepareBuilder();
        result.hasProbobility = false;
        result.probobility_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<string> WordsList {
        get { return PrepareBuilder().words_; }
      }
      public int WordsCount {
        get { return result.WordsCount; }
      }
      public string GetWords(int index) {
        return result.GetWords(index);
      }
      public Builder SetWords(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.words_[index] = value;
        return this;
      }
      public Builder AddWords(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.words_.Add(value);
        return this;
      }
      public Builder AddRangeWords(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.words_.Add(values);
        return this;
      }
      public Builder ClearWords() {
        PrepareBuilder();
        result.words_.Clear();
        return this;
      }
    }
    static BondQuoteInfo() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class RangeBondQuote : pb::GeneratedMessage<RangeBondQuote, RangeBondQuote.Builder> {
    private RangeBondQuote() { }
    private static readonly RangeBondQuote defaultInstance = new RangeBondQuote().MakeReadOnly();
    private static readonly string[] _rangeBondQuoteFieldNames = new string[] { "bondType", "direction", "lineNo", "probobility", "ratingEnd", "ratingStart", "termEnd", "termStart", "text", "volumeEnd", "volumeStart", "words" };
    private static readonly uint[] _rangeBondQuoteFieldTags = new uint[] { 66, 10, 176, 160, 42, 34, 26, 18, 170, 58, 50, 186 };
    public static RangeBondQuote DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override RangeBondQuote DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override RangeBondQuote ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_RangeBondQuote__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<RangeBondQuote, RangeBondQuote.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_RangeBondQuote__FieldAccessorTable; }
    }
    
    public const int DirectionFieldNumber = 1;
    private bool hasDirection;
    private string direction_ = "";
    public bool HasDirection {
      get { return hasDirection; }
    }
    public string Direction {
      get { return direction_; }
    }
    
    public const int TermStartFieldNumber = 2;
    private bool hasTermStart;
    private string termStart_ = "";
    public bool HasTermStart {
      get { return hasTermStart; }
    }
    public string TermStart {
      get { return termStart_; }
    }
    
    public const int TermEndFieldNumber = 3;
    private bool hasTermEnd;
    private string termEnd_ = "";
    public bool HasTermEnd {
      get { return hasTermEnd; }
    }
    public string TermEnd {
      get { return termEnd_; }
    }
    
    public const int RatingStartFieldNumber = 4;
    private bool hasRatingStart;
    private string ratingStart_ = "";
    public bool HasRatingStart {
      get { return hasRatingStart; }
    }
    public string RatingStart {
      get { return ratingStart_; }
    }
    
    public const int RatingEndFieldNumber = 5;
    private bool hasRatingEnd;
    private string ratingEnd_ = "";
    public bool HasRatingEnd {
      get { return hasRatingEnd; }
    }
    public string RatingEnd {
      get { return ratingEnd_; }
    }
    
    public const int VolumeStartFieldNumber = 6;
    private bool hasVolumeStart;
    private string volumeStart_ = "";
    public bool HasVolumeStart {
      get { return hasVolumeStart; }
    }
    public string VolumeStart {
      get { return volumeStart_; }
    }
    
    public const int VolumeEndFieldNumber = 7;
    private bool hasVolumeEnd;
    private string volumeEnd_ = "";
    public bool HasVolumeEnd {
      get { return hasVolumeEnd; }
    }
    public string VolumeEnd {
      get { return volumeEnd_; }
    }
    
    public const int BondTypeFieldNumber = 8;
    private pbc::PopsicleList<string> bondType_ = new pbc::PopsicleList<string>();
    public scg::IList<string> BondTypeList {
      get { return pbc::Lists.AsReadOnly(bondType_); }
    }
    public int BondTypeCount {
      get { return bondType_.Count; }
    }
    public string GetBondType(int index) {
      return bondType_[index];
    }
    
    public const int ProbobilityFieldNumber = 20;
    private bool hasProbobility;
    private int probobility_;
    public bool HasProbobility {
      get { return hasProbobility; }
    }
    public int Probobility {
      get { return probobility_; }
    }
    
    public const int TextFieldNumber = 21;
    private bool hasText;
    private string text_ = "";
    public bool HasText {
      get { return hasText; }
    }
    public string Text {
      get { return text_; }
    }
    
    public const int LineNoFieldNumber = 22;
    private bool hasLineNo;
    private int lineNo_;
    public bool HasLineNo {
      get { return hasLineNo; }
    }
    public int LineNo {
      get { return lineNo_; }
    }
    
    public const int WordsFieldNumber = 23;
    private pbc::PopsicleList<string> words_ = new pbc::PopsicleList<string>();
    public scg::IList<string> WordsList {
      get { return pbc::Lists.AsReadOnly(words_); }
    }
    public int WordsCount {
      get { return words_.Count; }
    }
    public string GetWords(int index) {
      return words_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasDirection) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _rangeBondQuoteFieldNames;
      if (hasDirection) {
        output.WriteString(1, field_names[1], Direction);
      }
      if (hasTermStart) {
        output.WriteString(2, field_names[7], TermStart);
      }
      if (hasTermEnd) {
        output.WriteString(3, field_names[6], TermEnd);
      }
      if (hasRatingStart) {
        output.WriteString(4, field_names[5], RatingStart);
      }
      if (hasRatingEnd) {
        output.WriteString(5, field_names[4], RatingEnd);
      }
      if (hasVolumeStart) {
        output.WriteString(6, field_names[10], VolumeStart);
      }
      if (hasVolumeEnd) {
        output.WriteString(7, field_names[9], VolumeEnd);
      }
      if (bondType_.Count > 0) {
        output.WriteStringArray(8, field_names[0], bondType_);
      }
      if (hasProbobility) {
        output.WriteInt32(20, field_names[3], Probobility);
      }
      if (hasText) {
        output.WriteString(21, field_names[8], Text);
      }
      if (hasLineNo) {
        output.WriteInt32(22, field_names[2], LineNo);
      }
      if (words_.Count > 0) {
        output.WriteStringArray(23, field_names[11], words_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasDirection) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Direction);
      }
      if (hasTermStart) {
        size += pb::CodedOutputStream.ComputeStringSize(2, TermStart);
      }
      if (hasTermEnd) {
        size += pb::CodedOutputStream.ComputeStringSize(3, TermEnd);
      }
      if (hasRatingStart) {
        size += pb::CodedOutputStream.ComputeStringSize(4, RatingStart);
      }
      if (hasRatingEnd) {
        size += pb::CodedOutputStream.ComputeStringSize(5, RatingEnd);
      }
      if (hasVolumeStart) {
        size += pb::CodedOutputStream.ComputeStringSize(6, VolumeStart);
      }
      if (hasVolumeEnd) {
        size += pb::CodedOutputStream.ComputeStringSize(7, VolumeEnd);
      }
      {
        int dataSize = 0;
        foreach (string element in BondTypeList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * bondType_.Count;
      }
      if (hasProbobility) {
        size += pb::CodedOutputStream.ComputeInt32Size(20, Probobility);
      }
      if (hasText) {
        size += pb::CodedOutputStream.ComputeStringSize(21, Text);
      }
      if (hasLineNo) {
        size += pb::CodedOutputStream.ComputeInt32Size(22, LineNo);
      }
      {
        int dataSize = 0;
        foreach (string element in WordsList) {
          dataSize += pb::CodedOutputStream.ComputeStringSizeNoTag(element);
        }
        size += dataSize;
        size += 2 * words_.Count;
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static RangeBondQuote ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RangeBondQuote ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RangeBondQuote ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static RangeBondQuote ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static RangeBondQuote ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RangeBondQuote ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static RangeBondQuote ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static RangeBondQuote ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static RangeBondQuote ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static RangeBondQuote ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private RangeBondQuote MakeReadOnly() {
      bondType_.MakeReadOnly();
      words_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(RangeBondQuote prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<RangeBondQuote, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(RangeBondQuote cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private RangeBondQuote result;
      
      private RangeBondQuote PrepareBuilder() {
        if (resultIsReadOnly) {
          RangeBondQuote original = result;
          result = new RangeBondQuote();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override RangeBondQuote MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.RangeBondQuote.Descriptor; }
      }
      
      public override RangeBondQuote DefaultInstanceForType {
        get { return global::Parsing.RangeBondQuote.DefaultInstance; }
      }
      
      public override RangeBondQuote BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is RangeBondQuote) {
          return MergeFrom((RangeBondQuote) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(RangeBondQuote other) {
        if (other == global::Parsing.RangeBondQuote.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasDirection) {
          Direction = other.Direction;
        }
        if (other.HasTermStart) {
          TermStart = other.TermStart;
        }
        if (other.HasTermEnd) {
          TermEnd = other.TermEnd;
        }
        if (other.HasRatingStart) {
          RatingStart = other.RatingStart;
        }
        if (other.HasRatingEnd) {
          RatingEnd = other.RatingEnd;
        }
        if (other.HasVolumeStart) {
          VolumeStart = other.VolumeStart;
        }
        if (other.HasVolumeEnd) {
          VolumeEnd = other.VolumeEnd;
        }
        if (other.bondType_.Count != 0) {
          result.bondType_.Add(other.bondType_);
        }
        if (other.HasProbobility) {
          Probobility = other.Probobility;
        }
        if (other.HasText) {
          Text = other.Text;
        }
        if (other.HasLineNo) {
          LineNo = other.LineNo;
        }
        if (other.words_.Count != 0) {
          result.words_.Add(other.words_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_rangeBondQuoteFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _rangeBondQuoteFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasDirection = input.ReadString(ref result.direction_);
              break;
            }
            case 18: {
              result.hasTermStart = input.ReadString(ref result.termStart_);
              break;
            }
            case 26: {
              result.hasTermEnd = input.ReadString(ref result.termEnd_);
              break;
            }
            case 34: {
              result.hasRatingStart = input.ReadString(ref result.ratingStart_);
              break;
            }
            case 42: {
              result.hasRatingEnd = input.ReadString(ref result.ratingEnd_);
              break;
            }
            case 50: {
              result.hasVolumeStart = input.ReadString(ref result.volumeStart_);
              break;
            }
            case 58: {
              result.hasVolumeEnd = input.ReadString(ref result.volumeEnd_);
              break;
            }
            case 66: {
              input.ReadStringArray(tag, field_name, result.bondType_);
              break;
            }
            case 160: {
              result.hasProbobility = input.ReadInt32(ref result.probobility_);
              break;
            }
            case 170: {
              result.hasText = input.ReadString(ref result.text_);
              break;
            }
            case 176: {
              result.hasLineNo = input.ReadInt32(ref result.lineNo_);
              break;
            }
            case 186: {
              input.ReadStringArray(tag, field_name, result.words_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasDirection {
        get { return result.hasDirection; }
      }
      public string Direction {
        get { return result.Direction; }
        set { SetDirection(value); }
      }
      public Builder SetDirection(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDirection = true;
        result.direction_ = value;
        return this;
      }
      public Builder ClearDirection() {
        PrepareBuilder();
        result.hasDirection = false;
        result.direction_ = "";
        return this;
      }
      
      public bool HasTermStart {
        get { return result.hasTermStart; }
      }
      public string TermStart {
        get { return result.TermStart; }
        set { SetTermStart(value); }
      }
      public Builder SetTermStart(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTermStart = true;
        result.termStart_ = value;
        return this;
      }
      public Builder ClearTermStart() {
        PrepareBuilder();
        result.hasTermStart = false;
        result.termStart_ = "";
        return this;
      }
      
      public bool HasTermEnd {
        get { return result.hasTermEnd; }
      }
      public string TermEnd {
        get { return result.TermEnd; }
        set { SetTermEnd(value); }
      }
      public Builder SetTermEnd(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTermEnd = true;
        result.termEnd_ = value;
        return this;
      }
      public Builder ClearTermEnd() {
        PrepareBuilder();
        result.hasTermEnd = false;
        result.termEnd_ = "";
        return this;
      }
      
      public bool HasRatingStart {
        get { return result.hasRatingStart; }
      }
      public string RatingStart {
        get { return result.RatingStart; }
        set { SetRatingStart(value); }
      }
      public Builder SetRatingStart(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRatingStart = true;
        result.ratingStart_ = value;
        return this;
      }
      public Builder ClearRatingStart() {
        PrepareBuilder();
        result.hasRatingStart = false;
        result.ratingStart_ = "";
        return this;
      }
      
      public bool HasRatingEnd {
        get { return result.hasRatingEnd; }
      }
      public string RatingEnd {
        get { return result.RatingEnd; }
        set { SetRatingEnd(value); }
      }
      public Builder SetRatingEnd(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRatingEnd = true;
        result.ratingEnd_ = value;
        return this;
      }
      public Builder ClearRatingEnd() {
        PrepareBuilder();
        result.hasRatingEnd = false;
        result.ratingEnd_ = "";
        return this;
      }
      
      public bool HasVolumeStart {
        get { return result.hasVolumeStart; }
      }
      public string VolumeStart {
        get { return result.VolumeStart; }
        set { SetVolumeStart(value); }
      }
      public Builder SetVolumeStart(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasVolumeStart = true;
        result.volumeStart_ = value;
        return this;
      }
      public Builder ClearVolumeStart() {
        PrepareBuilder();
        result.hasVolumeStart = false;
        result.volumeStart_ = "";
        return this;
      }
      
      public bool HasVolumeEnd {
        get { return result.hasVolumeEnd; }
      }
      public string VolumeEnd {
        get { return result.VolumeEnd; }
        set { SetVolumeEnd(value); }
      }
      public Builder SetVolumeEnd(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasVolumeEnd = true;
        result.volumeEnd_ = value;
        return this;
      }
      public Builder ClearVolumeEnd() {
        PrepareBuilder();
        result.hasVolumeEnd = false;
        result.volumeEnd_ = "";
        return this;
      }
      
      public pbc::IPopsicleList<string> BondTypeList {
        get { return PrepareBuilder().bondType_; }
      }
      public int BondTypeCount {
        get { return result.BondTypeCount; }
      }
      public string GetBondType(int index) {
        return result.GetBondType(index);
      }
      public Builder SetBondType(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.bondType_[index] = value;
        return this;
      }
      public Builder AddBondType(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.bondType_.Add(value);
        return this;
      }
      public Builder AddRangeBondType(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.bondType_.Add(values);
        return this;
      }
      public Builder ClearBondType() {
        PrepareBuilder();
        result.bondType_.Clear();
        return this;
      }
      
      public bool HasProbobility {
        get { return result.hasProbobility; }
      }
      public int Probobility {
        get { return result.Probobility; }
        set { SetProbobility(value); }
      }
      public Builder SetProbobility(int value) {
        PrepareBuilder();
        result.hasProbobility = true;
        result.probobility_ = value;
        return this;
      }
      public Builder ClearProbobility() {
        PrepareBuilder();
        result.hasProbobility = false;
        result.probobility_ = 0;
        return this;
      }
      
      public bool HasText {
        get { return result.hasText; }
      }
      public string Text {
        get { return result.Text; }
        set { SetText(value); }
      }
      public Builder SetText(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasText = true;
        result.text_ = value;
        return this;
      }
      public Builder ClearText() {
        PrepareBuilder();
        result.hasText = false;
        result.text_ = "";
        return this;
      }
      
      public bool HasLineNo {
        get { return result.hasLineNo; }
      }
      public int LineNo {
        get { return result.LineNo; }
        set { SetLineNo(value); }
      }
      public Builder SetLineNo(int value) {
        PrepareBuilder();
        result.hasLineNo = true;
        result.lineNo_ = value;
        return this;
      }
      public Builder ClearLineNo() {
        PrepareBuilder();
        result.hasLineNo = false;
        result.lineNo_ = 0;
        return this;
      }
      
      public pbc::IPopsicleList<string> WordsList {
        get { return PrepareBuilder().words_; }
      }
      public int WordsCount {
        get { return result.WordsCount; }
      }
      public string GetWords(int index) {
        return result.GetWords(index);
      }
      public Builder SetWords(int index, string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.words_[index] = value;
        return this;
      }
      public Builder AddWords(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.words_.Add(value);
        return this;
      }
      public Builder AddRangeWords(scg::IEnumerable<string> values) {
        PrepareBuilder();
        result.words_.Add(values);
        return this;
      }
      public Builder ClearWords() {
        PrepareBuilder();
        result.words_.Clear();
        return this;
      }
    }
    static RangeBondQuote() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class QuoteRsp : pb::GeneratedMessage<QuoteRsp, QuoteRsp.Builder> {
    private QuoteRsp() { }
    private static readonly QuoteRsp defaultInstance = new QuoteRsp().MakeReadOnly();
    private static readonly string[] _quoteRspFieldNames = new string[] { "IsDeal", "bondQuoteList", "company", "mmQuoteList", "otherQuote", "rangeQuoteList", "trader" };
    private static readonly uint[] _quoteRspFieldTags = new uint[] { 40, 18, 98, 10, 34, 26, 90 };
    public static QuoteRsp DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override QuoteRsp DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override QuoteRsp ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_QuoteRsp__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<QuoteRsp, QuoteRsp.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_QuoteRsp__FieldAccessorTable; }
    }
    
    public const int MmQuoteListFieldNumber = 1;
    private pbc::PopsicleList<global::Parsing.QuoteInfo> mmQuoteList_ = new pbc::PopsicleList<global::Parsing.QuoteInfo>();
    public scg::IList<global::Parsing.QuoteInfo> MmQuoteListList {
      get { return mmQuoteList_; }
    }
    public int MmQuoteListCount {
      get { return mmQuoteList_.Count; }
    }
    public global::Parsing.QuoteInfo GetMmQuoteList(int index) {
      return mmQuoteList_[index];
    }
    
    public const int BondQuoteListFieldNumber = 2;
    private pbc::PopsicleList<global::Parsing.BondQuoteInfo> bondQuoteList_ = new pbc::PopsicleList<global::Parsing.BondQuoteInfo>();
    public scg::IList<global::Parsing.BondQuoteInfo> BondQuoteListList {
      get { return bondQuoteList_; }
    }
    public int BondQuoteListCount {
      get { return bondQuoteList_.Count; }
    }
    public global::Parsing.BondQuoteInfo GetBondQuoteList(int index) {
      return bondQuoteList_[index];
    }
    
    public const int RangeQuoteListFieldNumber = 3;
    private pbc::PopsicleList<global::Parsing.RangeBondQuote> rangeQuoteList_ = new pbc::PopsicleList<global::Parsing.RangeBondQuote>();
    public scg::IList<global::Parsing.RangeBondQuote> RangeQuoteListList {
      get { return rangeQuoteList_; }
    }
    public int RangeQuoteListCount {
      get { return rangeQuoteList_.Count; }
    }
    public global::Parsing.RangeBondQuote GetRangeQuoteList(int index) {
      return rangeQuoteList_[index];
    }
    
    public const int OtherQuoteFieldNumber = 4;
    private bool hasOtherQuote;
    private global::Parsing.OtherQuote otherQuote_;
    public bool HasOtherQuote {
      get { return hasOtherQuote; }
    }
    public global::Parsing.OtherQuote OtherQuote {
      get { return otherQuote_ ?? global::Parsing.OtherQuote.DefaultInstance; }
    }
    
    public const int TraderFieldNumber = 11;
    private bool hasTrader;
    private string trader_ = "";
    public bool HasTrader {
      get { return hasTrader; }
    }
    public string Trader {
      get { return trader_; }
    }
    
    public const int CompanyFieldNumber = 12;
    private bool hasCompany;
    private string company_ = "";
    public bool HasCompany {
      get { return hasCompany; }
    }
    public string Company {
      get { return company_; }
    }
    
    public const int IsDealFieldNumber = 5;
    private bool hasIsDeal;
    private bool isDeal_;
    public bool HasIsDeal {
      get { return hasIsDeal; }
    }
    public bool IsDeal {
      get { return isDeal_; }
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Parsing.QuoteInfo element in MmQuoteListList) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Parsing.BondQuoteInfo element in BondQuoteListList) {
          if (!element.IsInitialized) return false;
        }
        foreach (global::Parsing.RangeBondQuote element in RangeQuoteListList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _quoteRspFieldNames;
      if (mmQuoteList_.Count > 0) {
        output.WriteMessageArray(1, field_names[3], mmQuoteList_);
      }
      if (bondQuoteList_.Count > 0) {
        output.WriteMessageArray(2, field_names[1], bondQuoteList_);
      }
      if (rangeQuoteList_.Count > 0) {
        output.WriteMessageArray(3, field_names[5], rangeQuoteList_);
      }
      if (hasOtherQuote) {
        output.WriteMessage(4, field_names[4], OtherQuote);
      }
      if (hasIsDeal) {
        output.WriteBool(5, field_names[0], IsDeal);
      }
      if (hasTrader) {
        output.WriteString(11, field_names[6], Trader);
      }
      if (hasCompany) {
        output.WriteString(12, field_names[2], Company);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Parsing.QuoteInfo element in MmQuoteListList) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      foreach (global::Parsing.BondQuoteInfo element in BondQuoteListList) {
        size += pb::CodedOutputStream.ComputeMessageSize(2, element);
      }
      foreach (global::Parsing.RangeBondQuote element in RangeQuoteListList) {
        size += pb::CodedOutputStream.ComputeMessageSize(3, element);
      }
      if (hasOtherQuote) {
        size += pb::CodedOutputStream.ComputeMessageSize(4, OtherQuote);
      }
      if (hasTrader) {
        size += pb::CodedOutputStream.ComputeStringSize(11, Trader);
      }
      if (hasCompany) {
        size += pb::CodedOutputStream.ComputeStringSize(12, Company);
      }
      if (hasIsDeal) {
        size += pb::CodedOutputStream.ComputeBoolSize(5, IsDeal);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static QuoteRsp ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static QuoteRsp ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static QuoteRsp ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static QuoteRsp ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static QuoteRsp ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static QuoteRsp ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static QuoteRsp ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static QuoteRsp ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static QuoteRsp ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static QuoteRsp ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private QuoteRsp MakeReadOnly() {
      mmQuoteList_.MakeReadOnly();
      bondQuoteList_.MakeReadOnly();
      rangeQuoteList_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(QuoteRsp prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<QuoteRsp, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(QuoteRsp cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private QuoteRsp result;
      
      private QuoteRsp PrepareBuilder() {
        if (resultIsReadOnly) {
          QuoteRsp original = result;
          result = new QuoteRsp();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override QuoteRsp MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.QuoteRsp.Descriptor; }
      }
      
      public override QuoteRsp DefaultInstanceForType {
        get { return global::Parsing.QuoteRsp.DefaultInstance; }
      }
      
      public override QuoteRsp BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is QuoteRsp) {
          return MergeFrom((QuoteRsp) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(QuoteRsp other) {
        if (other == global::Parsing.QuoteRsp.DefaultInstance) return this;
        PrepareBuilder();
        if (other.mmQuoteList_.Count != 0) {
          result.mmQuoteList_.Add(other.mmQuoteList_);
        }
        if (other.bondQuoteList_.Count != 0) {
          result.bondQuoteList_.Add(other.bondQuoteList_);
        }
        if (other.rangeQuoteList_.Count != 0) {
          result.rangeQuoteList_.Add(other.rangeQuoteList_);
        }
        if (other.HasOtherQuote) {
          MergeOtherQuote(other.OtherQuote);
        }
        if (other.HasTrader) {
          Trader = other.Trader;
        }
        if (other.HasCompany) {
          Company = other.Company;
        }
        if (other.HasIsDeal) {
          IsDeal = other.IsDeal;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_quoteRspFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _quoteRspFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.mmQuoteList_, global::Parsing.QuoteInfo.DefaultInstance, extensionRegistry);
              break;
            }
            case 18: {
              input.ReadMessageArray(tag, field_name, result.bondQuoteList_, global::Parsing.BondQuoteInfo.DefaultInstance, extensionRegistry);
              break;
            }
            case 26: {
              input.ReadMessageArray(tag, field_name, result.rangeQuoteList_, global::Parsing.RangeBondQuote.DefaultInstance, extensionRegistry);
              break;
            }
            case 34: {
              global::Parsing.OtherQuote.Builder subBuilder = global::Parsing.OtherQuote.CreateBuilder();
              if (result.hasOtherQuote) {
                subBuilder.MergeFrom(OtherQuote);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              OtherQuote = subBuilder.BuildPartial();
              break;
            }
            case 40: {
              result.hasIsDeal = input.ReadBool(ref result.isDeal_);
              break;
            }
            case 90: {
              result.hasTrader = input.ReadString(ref result.trader_);
              break;
            }
            case 98: {
              result.hasCompany = input.ReadString(ref result.company_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Parsing.QuoteInfo> MmQuoteListList {
        get { return PrepareBuilder().mmQuoteList_; }
      }
      public int MmQuoteListCount {
        get { return result.MmQuoteListCount; }
      }
      public global::Parsing.QuoteInfo GetMmQuoteList(int index) {
        return result.GetMmQuoteList(index);
      }
      public Builder SetMmQuoteList(int index, global::Parsing.QuoteInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.mmQuoteList_[index] = value;
        return this;
      }
      public Builder SetMmQuoteList(int index, global::Parsing.QuoteInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.mmQuoteList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddMmQuoteList(global::Parsing.QuoteInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.mmQuoteList_.Add(value);
        return this;
      }
      public Builder AddMmQuoteList(global::Parsing.QuoteInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.mmQuoteList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeMmQuoteList(scg::IEnumerable<global::Parsing.QuoteInfo> values) {
        PrepareBuilder();
        result.mmQuoteList_.Add(values);
        return this;
      }
      public Builder ClearMmQuoteList() {
        PrepareBuilder();
        result.mmQuoteList_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Parsing.BondQuoteInfo> BondQuoteListList {
        get { return PrepareBuilder().bondQuoteList_; }
      }
      public int BondQuoteListCount {
        get { return result.BondQuoteListCount; }
      }
      public global::Parsing.BondQuoteInfo GetBondQuoteList(int index) {
        return result.GetBondQuoteList(index);
      }
      public Builder SetBondQuoteList(int index, global::Parsing.BondQuoteInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.bondQuoteList_[index] = value;
        return this;
      }
      public Builder SetBondQuoteList(int index, global::Parsing.BondQuoteInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.bondQuoteList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddBondQuoteList(global::Parsing.BondQuoteInfo value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.bondQuoteList_.Add(value);
        return this;
      }
      public Builder AddBondQuoteList(global::Parsing.BondQuoteInfo.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.bondQuoteList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeBondQuoteList(scg::IEnumerable<global::Parsing.BondQuoteInfo> values) {
        PrepareBuilder();
        result.bondQuoteList_.Add(values);
        return this;
      }
      public Builder ClearBondQuoteList() {
        PrepareBuilder();
        result.bondQuoteList_.Clear();
        return this;
      }
      
      public pbc::IPopsicleList<global::Parsing.RangeBondQuote> RangeQuoteListList {
        get { return PrepareBuilder().rangeQuoteList_; }
      }
      public int RangeQuoteListCount {
        get { return result.RangeQuoteListCount; }
      }
      public global::Parsing.RangeBondQuote GetRangeQuoteList(int index) {
        return result.GetRangeQuoteList(index);
      }
      public Builder SetRangeQuoteList(int index, global::Parsing.RangeBondQuote value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rangeQuoteList_[index] = value;
        return this;
      }
      public Builder SetRangeQuoteList(int index, global::Parsing.RangeBondQuote.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rangeQuoteList_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddRangeQuoteList(global::Parsing.RangeBondQuote value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.rangeQuoteList_.Add(value);
        return this;
      }
      public Builder AddRangeQuoteList(global::Parsing.RangeBondQuote.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.rangeQuoteList_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeRangeQuoteList(scg::IEnumerable<global::Parsing.RangeBondQuote> values) {
        PrepareBuilder();
        result.rangeQuoteList_.Add(values);
        return this;
      }
      public Builder ClearRangeQuoteList() {
        PrepareBuilder();
        result.rangeQuoteList_.Clear();
        return this;
      }
      
      public bool HasOtherQuote {
       get { return result.hasOtherQuote; }
      }
      public global::Parsing.OtherQuote OtherQuote {
        get { return result.OtherQuote; }
        set { SetOtherQuote(value); }
      }
      public Builder SetOtherQuote(global::Parsing.OtherQuote value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOtherQuote = true;
        result.otherQuote_ = value;
        return this;
      }
      public Builder SetOtherQuote(global::Parsing.OtherQuote.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasOtherQuote = true;
        result.otherQuote_ = builderForValue.Build();
        return this;
      }
      public Builder MergeOtherQuote(global::Parsing.OtherQuote value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasOtherQuote &&
            result.otherQuote_ != global::Parsing.OtherQuote.DefaultInstance) {
            result.otherQuote_ = global::Parsing.OtherQuote.CreateBuilder(result.otherQuote_).MergeFrom(value).BuildPartial();
        } else {
          result.otherQuote_ = value;
        }
        result.hasOtherQuote = true;
        return this;
      }
      public Builder ClearOtherQuote() {
        PrepareBuilder();
        result.hasOtherQuote = false;
        result.otherQuote_ = null;
        return this;
      }
      
      public bool HasTrader {
        get { return result.hasTrader; }
      }
      public string Trader {
        get { return result.Trader; }
        set { SetTrader(value); }
      }
      public Builder SetTrader(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasTrader = true;
        result.trader_ = value;
        return this;
      }
      public Builder ClearTrader() {
        PrepareBuilder();
        result.hasTrader = false;
        result.trader_ = "";
        return this;
      }
      
      public bool HasCompany {
        get { return result.hasCompany; }
      }
      public string Company {
        get { return result.Company; }
        set { SetCompany(value); }
      }
      public Builder SetCompany(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCompany = true;
        result.company_ = value;
        return this;
      }
      public Builder ClearCompany() {
        PrepareBuilder();
        result.hasCompany = false;
        result.company_ = "";
        return this;
      }
      
      public bool HasIsDeal {
        get { return result.hasIsDeal; }
      }
      public bool IsDeal {
        get { return result.IsDeal; }
        set { SetIsDeal(value); }
      }
      public Builder SetIsDeal(bool value) {
        PrepareBuilder();
        result.hasIsDeal = true;
        result.isDeal_ = value;
        return this;
      }
      public Builder ClearIsDeal() {
        PrepareBuilder();
        result.hasIsDeal = false;
        result.isDeal_ = false;
        return this;
      }
    }
    static QuoteRsp() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SegmentationReq : pb::GeneratedMessage<SegmentationReq, SegmentationReq.Builder> {
    private SegmentationReq() { }
    private static readonly SegmentationReq defaultInstance = new SegmentationReq().MakeReadOnly();
    private static readonly string[] _segmentationReqFieldNames = new string[] { "text" };
    private static readonly uint[] _segmentationReqFieldTags = new uint[] { 10 };
    public static SegmentationReq DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SegmentationReq DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SegmentationReq ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_SegmentationReq__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SegmentationReq, SegmentationReq.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_SegmentationReq__FieldAccessorTable; }
    }
    
    public const int TextFieldNumber = 1;
    private bool hasText;
    private string text_ = "";
    public bool HasText {
      get { return hasText; }
    }
    public string Text {
      get { return text_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasText) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _segmentationReqFieldNames;
      if (hasText) {
        output.WriteString(1, field_names[0], Text);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasText) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Text);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static SegmentationReq ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SegmentationReq ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SegmentationReq ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SegmentationReq ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SegmentationReq ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SegmentationReq ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SegmentationReq ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SegmentationReq ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SegmentationReq ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SegmentationReq ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SegmentationReq MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SegmentationReq prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<SegmentationReq, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SegmentationReq cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SegmentationReq result;
      
      private SegmentationReq PrepareBuilder() {
        if (resultIsReadOnly) {
          SegmentationReq original = result;
          result = new SegmentationReq();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SegmentationReq MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.SegmentationReq.Descriptor; }
      }
      
      public override SegmentationReq DefaultInstanceForType {
        get { return global::Parsing.SegmentationReq.DefaultInstance; }
      }
      
      public override SegmentationReq BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SegmentationReq) {
          return MergeFrom((SegmentationReq) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SegmentationReq other) {
        if (other == global::Parsing.SegmentationReq.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasText) {
          Text = other.Text;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_segmentationReqFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _segmentationReqFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasText = input.ReadString(ref result.text_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasText {
        get { return result.hasText; }
      }
      public string Text {
        get { return result.Text; }
        set { SetText(value); }
      }
      public Builder SetText(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasText = true;
        result.text_ = value;
        return this;
      }
      public Builder ClearText() {
        PrepareBuilder();
        result.hasText = false;
        result.text_ = "";
        return this;
      }
    }
    static SegmentationReq() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class AddWordMapReq : pb::GeneratedMessage<AddWordMapReq, AddWordMapReq.Builder> {
    private AddWordMapReq() { }
    private static readonly AddWordMapReq defaultInstance = new AddWordMapReq().MakeReadOnly();
    private static readonly string[] _addWordMapReqFieldNames = new string[] { "GroupType", "Input", "Output", "Value" };
    private static readonly uint[] _addWordMapReqFieldTags = new uint[] { 10, 18, 26, 34 };
    public static AddWordMapReq DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AddWordMapReq DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AddWordMapReq ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_AddWordMapReq__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AddWordMapReq, AddWordMapReq.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_AddWordMapReq__FieldAccessorTable; }
    }
    
    public const int GroupTypeFieldNumber = 1;
    private bool hasGroupType;
    private string groupType_ = "";
    public bool HasGroupType {
      get { return hasGroupType; }
    }
    public string GroupType {
      get { return groupType_; }
    }
    
    public const int InputFieldNumber = 2;
    private bool hasInput;
    private string input_ = "";
    public bool HasInput {
      get { return hasInput; }
    }
    public string Input {
      get { return input_; }
    }
    
    public const int OutputFieldNumber = 3;
    private bool hasOutput;
    private string output_ = "";
    public bool HasOutput {
      get { return hasOutput; }
    }
    public string Output {
      get { return output_; }
    }
    
    public const int ValueFieldNumber = 4;
    private bool hasValue;
    private string value_ = "";
    public bool HasValue {
      get { return hasValue; }
    }
    public string Value {
      get { return value_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasGroupType) return false;
        if (!hasInput) return false;
        if (!hasOutput) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _addWordMapReqFieldNames;
      if (hasGroupType) {
        output.WriteString(1, field_names[0], GroupType);
      }
      if (hasInput) {
        output.WriteString(2, field_names[1], Input);
      }
      if (hasOutput) {
        output.WriteString(3, field_names[2], Output);
      }
      if (hasValue) {
        output.WriteString(4, field_names[3], Value);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasGroupType) {
        size += pb::CodedOutputStream.ComputeStringSize(1, GroupType);
      }
      if (hasInput) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Input);
      }
      if (hasOutput) {
        size += pb::CodedOutputStream.ComputeStringSize(3, Output);
      }
      if (hasValue) {
        size += pb::CodedOutputStream.ComputeStringSize(4, Value);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static AddWordMapReq ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AddWordMapReq ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AddWordMapReq ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AddWordMapReq ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AddWordMapReq ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AddWordMapReq ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AddWordMapReq ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AddWordMapReq ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AddWordMapReq ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AddWordMapReq ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AddWordMapReq MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AddWordMapReq prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<AddWordMapReq, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AddWordMapReq cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AddWordMapReq result;
      
      private AddWordMapReq PrepareBuilder() {
        if (resultIsReadOnly) {
          AddWordMapReq original = result;
          result = new AddWordMapReq();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AddWordMapReq MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.AddWordMapReq.Descriptor; }
      }
      
      public override AddWordMapReq DefaultInstanceForType {
        get { return global::Parsing.AddWordMapReq.DefaultInstance; }
      }
      
      public override AddWordMapReq BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AddWordMapReq) {
          return MergeFrom((AddWordMapReq) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AddWordMapReq other) {
        if (other == global::Parsing.AddWordMapReq.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasGroupType) {
          GroupType = other.GroupType;
        }
        if (other.HasInput) {
          Input = other.Input;
        }
        if (other.HasOutput) {
          Output = other.Output;
        }
        if (other.HasValue) {
          Value = other.Value;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_addWordMapReqFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _addWordMapReqFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasGroupType = input.ReadString(ref result.groupType_);
              break;
            }
            case 18: {
              result.hasInput = input.ReadString(ref result.input_);
              break;
            }
            case 26: {
              result.hasOutput = input.ReadString(ref result.output_);
              break;
            }
            case 34: {
              result.hasValue = input.ReadString(ref result.value_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasGroupType {
        get { return result.hasGroupType; }
      }
      public string GroupType {
        get { return result.GroupType; }
        set { SetGroupType(value); }
      }
      public Builder SetGroupType(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasGroupType = true;
        result.groupType_ = value;
        return this;
      }
      public Builder ClearGroupType() {
        PrepareBuilder();
        result.hasGroupType = false;
        result.groupType_ = "";
        return this;
      }
      
      public bool HasInput {
        get { return result.hasInput; }
      }
      public string Input {
        get { return result.Input; }
        set { SetInput(value); }
      }
      public Builder SetInput(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasInput = true;
        result.input_ = value;
        return this;
      }
      public Builder ClearInput() {
        PrepareBuilder();
        result.hasInput = false;
        result.input_ = "";
        return this;
      }
      
      public bool HasOutput {
        get { return result.hasOutput; }
      }
      public string Output {
        get { return result.Output; }
        set { SetOutput(value); }
      }
      public Builder SetOutput(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasOutput = true;
        result.output_ = value;
        return this;
      }
      public Builder ClearOutput() {
        PrepareBuilder();
        result.hasOutput = false;
        result.output_ = "";
        return this;
      }
      
      public bool HasValue {
        get { return result.hasValue; }
      }
      public string Value {
        get { return result.Value; }
        set { SetValue(value); }
      }
      public Builder SetValue(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasValue = true;
        result.value_ = value;
        return this;
      }
      public Builder ClearValue() {
        PrepareBuilder();
        result.hasValue = false;
        result.value_ = "";
        return this;
      }
    }
    static AddWordMapReq() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class AddWordMapRsp : pb::GeneratedMessage<AddWordMapRsp, AddWordMapRsp.Builder> {
    private AddWordMapRsp() { }
    private static readonly AddWordMapRsp defaultInstance = new AddWordMapRsp().MakeReadOnly();
    private static readonly string[] _addWordMapRspFieldNames = new string[] { "ret" };
    private static readonly uint[] _addWordMapRspFieldTags = new uint[] { 10 };
    public static AddWordMapRsp DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AddWordMapRsp DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AddWordMapRsp ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_AddWordMapRsp__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<AddWordMapRsp, AddWordMapRsp.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_AddWordMapRsp__FieldAccessorTable; }
    }
    
    public const int RetFieldNumber = 1;
    private bool hasRet;
    private string ret_ = "";
    public bool HasRet {
      get { return hasRet; }
    }
    public string Ret {
      get { return ret_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasRet) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _addWordMapRspFieldNames;
      if (hasRet) {
        output.WriteString(1, field_names[0], Ret);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasRet) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Ret);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static AddWordMapRsp ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AddWordMapRsp ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AddWordMapRsp ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AddWordMapRsp ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AddWordMapRsp ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AddWordMapRsp ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AddWordMapRsp ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AddWordMapRsp ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AddWordMapRsp ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AddWordMapRsp ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AddWordMapRsp MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AddWordMapRsp prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<AddWordMapRsp, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AddWordMapRsp cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AddWordMapRsp result;
      
      private AddWordMapRsp PrepareBuilder() {
        if (resultIsReadOnly) {
          AddWordMapRsp original = result;
          result = new AddWordMapRsp();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AddWordMapRsp MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.AddWordMapRsp.Descriptor; }
      }
      
      public override AddWordMapRsp DefaultInstanceForType {
        get { return global::Parsing.AddWordMapRsp.DefaultInstance; }
      }
      
      public override AddWordMapRsp BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is AddWordMapRsp) {
          return MergeFrom((AddWordMapRsp) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AddWordMapRsp other) {
        if (other == global::Parsing.AddWordMapRsp.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasRet) {
          Ret = other.Ret;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_addWordMapRspFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _addWordMapRspFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasRet = input.ReadString(ref result.ret_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasRet {
        get { return result.hasRet; }
      }
      public string Ret {
        get { return result.Ret; }
        set { SetRet(value); }
      }
      public Builder SetRet(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasRet = true;
        result.ret_ = value;
        return this;
      }
      public Builder ClearRet() {
        PrepareBuilder();
        result.hasRet = false;
        result.ret_ = "";
        return this;
      }
    }
    static AddWordMapRsp() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Word : pb::GeneratedMessage<Word, Word.Builder> {
    private Word() { }
    private static readonly Word defaultInstance = new Word().MakeReadOnly();
    private static readonly string[] _wordFieldNames = new string[] { "type", "word" };
    private static readonly uint[] _wordFieldTags = new uint[] { 18, 10 };
    public static Word DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Word DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Word ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_Word__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Word, Word.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_Word__FieldAccessorTable; }
    }
    
    public const int Word_FieldNumber = 1;
    private bool hasWord_;
    private string word_ = "";
    public bool HasWord_ {
      get { return hasWord_; }
    }
    public string Word_ {
      get { return word_; }
    }
    
    public const int TypeFieldNumber = 2;
    private bool hasType;
    private string type_ = "";
    public bool HasType {
      get { return hasType; }
    }
    public string Type {
      get { return type_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasWord_) return false;
        if (!hasType) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _wordFieldNames;
      if (hasWord_) {
        output.WriteString(1, field_names[1], Word_);
      }
      if (hasType) {
        output.WriteString(2, field_names[0], Type);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasWord_) {
        size += pb::CodedOutputStream.ComputeStringSize(1, Word_);
      }
      if (hasType) {
        size += pb::CodedOutputStream.ComputeStringSize(2, Type);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static Word ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Word ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Word ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Word ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Word ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Word ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Word ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Word ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Word ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Word ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Word MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Word prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Word, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Word cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Word result;
      
      private Word PrepareBuilder() {
        if (resultIsReadOnly) {
          Word original = result;
          result = new Word();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Word MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.Word.Descriptor; }
      }
      
      public override Word DefaultInstanceForType {
        get { return global::Parsing.Word.DefaultInstance; }
      }
      
      public override Word BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Word) {
          return MergeFrom((Word) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Word other) {
        if (other == global::Parsing.Word.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasWord_) {
          Word_ = other.Word_;
        }
        if (other.HasType) {
          Type = other.Type;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_wordFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _wordFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasWord_ = input.ReadString(ref result.word_);
              break;
            }
            case 18: {
              result.hasType = input.ReadString(ref result.type_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasWord_ {
        get { return result.hasWord_; }
      }
      public string Word_ {
        get { return result.Word_; }
        set { SetWord_(value); }
      }
      public Builder SetWord_(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasWord_ = true;
        result.word_ = value;
        return this;
      }
      public Builder ClearWord_() {
        PrepareBuilder();
        result.hasWord_ = false;
        result.word_ = "";
        return this;
      }
      
      public bool HasType {
        get { return result.hasType; }
      }
      public string Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = "";
        return this;
      }
    }
    static Word() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SegmentationRsp : pb::GeneratedMessage<SegmentationRsp, SegmentationRsp.Builder> {
    private SegmentationRsp() { }
    private static readonly SegmentationRsp defaultInstance = new SegmentationRsp().MakeReadOnly();
    private static readonly string[] _segmentationRspFieldNames = new string[] { "info" };
    private static readonly uint[] _segmentationRspFieldTags = new uint[] { 10 };
    public static SegmentationRsp DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override SegmentationRsp DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override SegmentationRsp ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Parsing.Parsing.internal__static_Parsing_SegmentationRsp__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<SegmentationRsp, SegmentationRsp.Builder> InternalFieldAccessors {
      get { return global::Parsing.Parsing.internal__static_Parsing_SegmentationRsp__FieldAccessorTable; }
    }
    
    public const int InfoFieldNumber = 1;
    private pbc::PopsicleList<global::Parsing.Word> info_ = new pbc::PopsicleList<global::Parsing.Word>();
    public scg::IList<global::Parsing.Word> InfoList {
      get { return info_; }
    }
    public int InfoCount {
      get { return info_.Count; }
    }
    public global::Parsing.Word GetInfo(int index) {
      return info_[index];
    }
    
    public override bool IsInitialized {
      get {
        foreach (global::Parsing.Word element in InfoList) {
          if (!element.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _segmentationRspFieldNames;
      if (info_.Count > 0) {
        output.WriteMessageArray(1, field_names[0], info_);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      foreach (global::Parsing.Word element in InfoList) {
        size += pb::CodedOutputStream.ComputeMessageSize(1, element);
      }
      size += UnknownFields.SerializedSize;
      memoizedSerializedSize = size;
      return size;
    }
    public static SegmentationRsp ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SegmentationRsp ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SegmentationRsp ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static SegmentationRsp ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static SegmentationRsp ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SegmentationRsp ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static SegmentationRsp ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static SegmentationRsp ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static SegmentationRsp ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static SegmentationRsp ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private SegmentationRsp MakeReadOnly() {
      info_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(SegmentationRsp prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<SegmentationRsp, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(SegmentationRsp cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private SegmentationRsp result;
      
      private SegmentationRsp PrepareBuilder() {
        if (resultIsReadOnly) {
          SegmentationRsp original = result;
          result = new SegmentationRsp();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override SegmentationRsp MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Parsing.SegmentationRsp.Descriptor; }
      }
      
      public override SegmentationRsp DefaultInstanceForType {
        get { return global::Parsing.SegmentationRsp.DefaultInstance; }
      }
      
      public override SegmentationRsp BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is SegmentationRsp) {
          return MergeFrom((SegmentationRsp) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(SegmentationRsp other) {
        if (other == global::Parsing.SegmentationRsp.DefaultInstance) return this;
        PrepareBuilder();
        if (other.info_.Count != 0) {
          result.info_.Add(other.info_);
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_segmentationRspFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _segmentationRspFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              input.ReadMessageArray(tag, field_name, result.info_, global::Parsing.Word.DefaultInstance, extensionRegistry);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public pbc::IPopsicleList<global::Parsing.Word> InfoList {
        get { return PrepareBuilder().info_; }
      }
      public int InfoCount {
        get { return result.InfoCount; }
      }
      public global::Parsing.Word GetInfo(int index) {
        return result.GetInfo(index);
      }
      public Builder SetInfo(int index, global::Parsing.Word value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.info_[index] = value;
        return this;
      }
      public Builder SetInfo(int index, global::Parsing.Word.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.info_[index] = builderForValue.Build();
        return this;
      }
      public Builder AddInfo(global::Parsing.Word value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.info_.Add(value);
        return this;
      }
      public Builder AddInfo(global::Parsing.Word.Builder builderForValue) {
        pb::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.info_.Add(builderForValue.Build());
        return this;
      }
      public Builder AddRangeInfo(scg::IEnumerable<global::Parsing.Word> values) {
        PrepareBuilder();
        result.info_.Add(values);
        return this;
      }
      public Builder ClearInfo() {
        PrepareBuilder();
        result.info_.Clear();
        return this;
      }
    }
    static SegmentationRsp() {
      object.ReferenceEquals(global::Parsing.Parsing.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
